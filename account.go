package main

import (
	"bytes"
	"crypto/md5"
	"encoding/binary"
	"encoding/json"
	"log"
	"math"
	"os"
	"sort"
	"strings"
	"time"

	"github.com/leekchan/accounting"
)

type Transaction struct {
	date  time.Time
	event *Event
	hash  uint64
}

func (t *Transaction) repeats() bool {
	return t.event.Frequency != Once
}

func (t *Transaction) isFirstOccurrence() bool {
	return t.date.Equal(t.event.Date)
}

func (t *Transaction) calculateHash() {
	hasher := md5.New()

	amount := make([]byte, 4)
	binary.LittleEndian.PutUint32(amount, math.Float32bits(t.event.Amount))

	frequency := make([]byte, 1)
	frequency[0] = uint8(t.event.Frequency)

	hasher.Write([]byte(t.event.Description))
	hasher.Write(amount)
	hasher.Write(frequency)

	// calculate the hash and store it in the transaction
	hash := hasher.Sum(nil)
	binary.Read(bytes.NewReader(hash[:8]), binary.LittleEndian, &t.hash)
}

type byDate []Transaction

func (t byDate) Len() int {
	return len(t)
}
func (t byDate) Swap(i int, j int) {
	t[i], t[j] = t[j], t[i]
}
func (t byDate) Less(i int, j int) bool {
	if t[i].date.Equal(t[j].date) {
		return t[i].event.Amount > t[j].event.Amount
	}

	return t[i].date.Before(t[j].date)
}

type Account struct {
	config_path string
	currency    accounting.Accounting

	Balance float32
	Events  []Event
}

func newAccount(path *string) Account {
	account_str, err := os.ReadFile(*path)
	if err != nil {
		log.Fatal(err)
	}

	var account Account
	if err := json.Unmarshal(account_str, &account); err != nil {
		log.Fatal(err)
	}

	account.config_path = *path
	account.currency = accounting.Accounting{Symbol: "$", Precision: 2}
	return account
}

func (a *Account) addEvent(event *Event) {
	a.Events = append(a.Events, *event)
}

func (a *Account) deleteEvent(i int) {
	last := len(a.Events) - 1
	a.Events[i] = a.Events[last]
	a.Events = a.Events[:last]
}

func (a *Account) save() {
	result, err := json.MarshalIndent(a, "", strings.Repeat(" ", 4))
	if err != nil {
		log.Fatal(err)
	}

	if err := os.WriteFile(a.config_path, result, 0); err != nil {
		log.Fatal(err)
	}
}

func (a *Account) reload() {
	account_str, err := os.ReadFile(a.config_path)
	if err != nil {
		log.Fatal(err)
	}

	if err := json.Unmarshal(account_str, a); err != nil {
		log.Fatal(err)
	}
}

func (a *Account) predict(until time.Time) []Transaction {
	transactions := []Transaction{}

	for i := range a.Events {
		transactions = append(transactions, a.Events[i].predict(until)...)
	}

	sort.Sort(byDate(transactions))
	return transactions
}

func (a *Account) findEventIndex(tx *Transaction) int {
	for i, event := range a.Events {
		if *tx.event == event {
			return i
		}
	}

	return -1
}

func (a *Account) txComplete(tx *Transaction, update_balance bool) {
	if tx.repeats() && !tx.isFirstOccurrence() {
		// disallow marking done a future transaction generated by a repeating event
		return
	}

	if update_balance {
		a.Balance += tx.event.Amount
	}

	if !tx.repeats() {
		i := a.findEventIndex(tx)
		a.deleteEvent(i)
		return
	}

	tx.event.Date = tx.event.nextOccurrence(tx.event.Date)
}

func (a *Account) txDatePrevious(tx *Transaction) {
	tx.event.Date = tx.event.Date.AddDate(0, 0, -1)
}

func (a *Account) txDateNext(tx *Transaction) {
	tx.event.Date = tx.event.Date.AddDate(0, 0, 1)
}

func (a *Account) txSetToToday(tx *Transaction) {
	if tx.repeats() && !tx.isFirstOccurrence() {
		// doesn't make sense to place a future occurrence of a repeating event to be paid today when
		// there is an earlier occurrence
		return
	}

	now := time.Now().Round(24 * time.Hour)
	if !tx.repeats() {
		// no need to do any splitting logic if the event never repeats
		tx.event.Date = time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, time.Local)
		return
	}

	new_event := *tx.event
	new_event.Frequency = Once
	new_event.Date = time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, time.Local)
	a.Events = append(a.Events, new_event)

	tx.event.Date = tx.event.nextOccurrence(tx.event.Date)
}
